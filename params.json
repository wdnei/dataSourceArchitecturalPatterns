{"name":"Data Source Architectural Patterns","tagline":"Este projeto foi criado a partir de uma apresentação sobre Data Source Architectural Patterns na disciplina de Laboratório de Engenharia de Software.","body":"***\r\n###criado por Wdnei Paixão\r\n***\r\n\r\n\r\n##Introdução\r\nO coração de todo aplicativo é o acesso a dados. Desenvolvedores passam muito de seu tempo projetando, avaliando, testando e se preocupando com as formas de acesso a dados em seus sistemas. Assim, é eminente o surgimento de padrões comuns para escrever código da camada de acesso a dados.\r\n\r\nO padrões de acesso a dados apresentados aqui foram definidos por Martin Fowler, são eles:\r\n\r\n*Table Data Gateway\r\n*Row Data Gateway\r\n*Active Record\r\n*Data Wrapper\r\n\r\n##Table Data Gateway\r\n\r\n![Exemplo Table Data Gateway](https://raw.githubusercontent.com/wdnei/dataSourceArchitecturalPatterns/master/dataSourceArchitecturalPatterns/UMLDiagrams/Images/TableDataGateway.png)\r\n\r\nEste Padrão é também denominado como Data Access Object(DAO)\r\nUm objeto que age como um Gateway(Ponte/Porta de Entrada) as tabelas do banco de dados.\r\nTable Data Gateway inclui todos comando SQL para acessar uma única tabela ou view: selects, inserts, updates, and deletes.\r\nAs propriedades são implementadas de acordo com a necessidade. \r\n\r\n###Porque usar:\r\n-Encapsular os comando SQL e manter o acesso ao banco mais transparente\r\n-Evitar repetição de codigo\r\n\r\n###Quando Usar:\r\n-Table Data Gateway trabalha perfeitamente com Table Module, onde produz um DataSet para trabalhar com as tabelas do banco em memória.\r\n-Quando há o uso de Transaction Script.\r\n\r\n\r\n##Row Data Gateway\r\n\r\n![Exemplo Row Data Gateway](https://raw.githubusercontent.com/wdnei/dataSourceArchitecturalPatterns/master/dataSourceArchitecturalPatterns/UMLDiagrams/Images/RowDataGateway.png)\r\n\r\nRow Data Gateway representa objetos exatamente como as linhas das tabelas do banco de dados , mas que podem ser acessados por mecanismos em linguagens de programação. Todos os detalhes de acesso ao banco são escondidas usando interfaces. \r\nProblema com múltiplas instancias do mesmo registro. Necessita implementar todas as propriedades de acesso.\r\n\r\n###Porque usar:\r\n-Evitar repetição de código.\r\n-Quando não há o uso de classes de domínio.\r\n\r\n###Quando Usar:\r\n-Quando há o uso de Transaction Scripts.\r\n\r\n##Active Record\r\n\r\n![Exemplo Active Record](https://raw.githubusercontent.com/wdnei/dataSourceArchitecturalPatterns/master/dataSourceArchitecturalPatterns/UMLDiagrams/Images/ActiveRecord.png)\r\n\r\nUma classe contem as propriedades da tabela, encapsula o código de acesso(SQL) ao banco de dados, e também contém a lógica de negócio, ou seja, um objeto contém ambos dados e comportamento. Entretanto, há problemas com múltiplas instancias do mesmo registro.\r\n\r\n###Porque/Quando Usar:\r\n-Boa escolha quando há o uso de Domain Model\r\n-Quando há a necessidade de mesclar acesso a dados e a lógica de negócio\r\n-Quando não há muita complexidade: herança, relação entre objetos.\r\n\r\n##Data Wrapper\r\n![Exemplo Data Mapper](https://raw.githubusercontent.com/wdnei/dataSourceArchitecturalPatterns/master/dataSourceArchitecturalPatterns/UMLDiagrams/Images/DataMapper.png)\r\n\r\nUma camada que mapeia e move dados entre objetos e banco de dados, os mantendo independentes. Busca um registro no banco de dados e cria um objeto com as propriedades preenchidas. Onde há o isolamento do acesso ao banco de dados e da lógica de négocio. Podendo usar Lazy Load para resolver relacionamento de dados.\r\n\r\n###Abordagens de implementação:\r\n-Uso de ferramentas para criar classes a partir do mapeamento do banco.\r\n-Uso de Metadata e Reflection \r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}